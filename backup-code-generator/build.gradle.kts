import org.beryx.jlink.JPackageImageTask
import org.beryx.jlink.PrepareMergedJarsDirTask
import org.beryx.jlink.data.JlinkPluginExtension
import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform
import org.gradle.nativeplatform.platform.internal.DefaultOperatingSystem

/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.3/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    application

    // Plugin to work with JavaFX
    id("org.openjfx.javafxplugin") version "0.1.0"

    // Plugin to work with IntelliJ IDEA.
    idea

    // Plugin to create a native image.
    id("org.beryx.jlink") version "3.0.1"
}

group = "cypher.enforcers"
version = "1.0.0"

// Adds the module version to the module-info.java file.
tasks.named<JavaCompile>("compileJava") {
    options.javaModuleVersion = provider { version as String }
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

val m1Configuration by configurations.creating {
    extendsFrom(configurations.runtimeClasspath.get())
    exclude(group = "org.openjfx")
}

val os: DefaultOperatingSystem = DefaultNativePlatform.getCurrentOperatingSystem()

dependencies {
    // Logging API.
    implementation("org.slf4j:slf4j-api:2.0.9")

    // Logging implementation.
    implementation("ch.qos.logback:logback-classic:1.4.11") {
        // This is because logback brings in a transitive
        // dependency to SLF4J, even though we have already
        // imported it. No need for it to be imported twice.
        exclude("org.slf4j", "slf4j-api")
    }

    // ValidatorFX.
    implementation("net.synedra:validatorfx:0.4.2")

    // ControlsFX.
    implementation("org.controlsfx:controlsfx:11.1.2")

    // SQLite support.
    implementation("org.xerial:sqlite-jdbc:3.43.2.2")

    // Junit5 in our case needs two modules.
    // Junit jupiter -> This is for the @Test annotations and the assertions
    // such as asserTrue, assertEquals, etc.
    // Junit platform -> This is what launches the testing framework on the
    // JVM.
    testImplementation(platform("org.junit:junit-bom:5.10.0"))
    testImplementation("org.junit.jupiter:junit-jupiter")

    // Using runtime only because this dependency is only needed
    // when running the tests.
    testRuntimeOnly("org.junit.platform:junit-platform-launcher") {
        because("Only needed to run tests in a version of IntelliJ IDEA that bundles older versions.")
    }

    // Used to extract filename from an url.
    implementation("commons-io:commons-io:2.15.0")

    val isCI = providers.gradleProperty("isCI")
    if (os.isMacOsX && isCI.isPresent) {
        m1Configuration("org.openjfx:javafx-controls:21:mac-aarch64")
        m1Configuration("org.openjfx:javafx-fxml:21:mac-aarch64")
    }
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
        vendor = JvmVendorSpec.ADOPTIUM // To use OpenJDK.
    }
}

application {
    // Define the main module for the application.
    mainModule = "backup.code.generator"

    // Define the main class for the application.
    mainClass = "cypher.enforcers.Launcher"
}

val cleanUpTask: TaskProvider<Delete> = tasks.register<Delete>("cleanUpTestFiles") {
    group = "verification"
    description = "Cleans up the files created by the" +
            "tests."

    // This is to remove files copied from resources.
    // These files are modified after the tests are complete, so they
    // need to be copied again to return to their original state.
    delete(fileTree(layout.projectDirectory) {
        include("*.db")
        exclude("database.db")
    })
}

tasks.named<Test>("test") {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()

    // Clean up old files.
    finalizedBy(cleanUpTask)

    // Show tests that failed and passed.
    testLogging {
        events("passed", "failed")
    }
}

javafx {
    // This is the equivalent of doing
    // --module-path=path/to/javafx/lib/folder --add-modules=javafx.fxml,
    // javafx.controls in the run configuration of IntelliJ IDEA.

    version = "21"
    modules = listOf("javafx.controls", "javafx.fxml")
}

tasks.named<Delete>("clean") {
    // This is to remove the log file.
    delete(layout.projectDirectory.file("logs.log"))
}

// To work with projects inside IntelliJ IDEA.
idea {
    module {
        inheritOutputDirs = true
    }
}

jlink {
    options.set(listOf(
        "--compress",
        "zip-9",
        "--no-header-files",
        "--no-man-pages",
        "--strip-debug"
    ))

    jpackage {
        appVersion = version.toString()
        imageName = "Backup Code Generator"
        installerOptions.addAll(
            listOf(
                "--app-version", version.toString()
            )
        )
    }

    if (os.isWindows) {
        jpackage {
            installerType = "msi"
            installerOptions.addAll(
                listOf(
                    "--win-dir-chooser",
                    "--win-shortcut-prompt"
                )
            )
        }
    } else if (os.isMacOsX) {
        jpackage {
            installerType = "dmg"
        }
    } else if (os.isLinux) {
    }

}

// Had some issues, so customized the default task to make a native
// image.
tasks.named<JPackageImageTask>("jpackageImage") {
    doLast {
        /*
        On Windows, JPackage for some reason makes the native image file
        (.exe on Windows) read only, so Gradle can't delete it when using
        the clean task.
        The code below modifies the permission of the
        produced file, so it can be deleted on Windows.
         */
        if (os.isWindows) {
            layout.buildDirectory.file(
                jpackageData.imageOutputDir.name
                + File.separator
                + jpackageData.imageName
                + File.separator
                + jpackageData.imageName + ".exe"
            ).get().asFile.setWritable(true)
        }
    }
}

tasks.named<Jar>("jar") {
    val isCI = providers.gradleProperty("isCI")
    doFirst {
        if (isCI.isPresent) {
            if (os.isWindows) {
                archiveClassifier = "win"
            } else if (os.isLinux) {
                archiveClassifier = "linux"
            } else if (os.isWindows) {
                archiveClassifier = "mac"
            }
        }
    }

}

// Task to create an uber or jar fat.
tasks.register<Jar>("uberJar") {
    group = "build"
    description = "Creates an uberJar."

    destinationDirectory = layout.buildDirectory.dir("uberJars")
    archiveClassifier = "uber"

    from(sourceSets.main.get().output)

    dependsOn(configurations.runtimeClasspath)
    from({
        configurations.runtimeClasspath.get().filter { it.name.endsWith("jar") }.map { zipTree(it) }
    }) {
    }

    exclude("module-info.class")
    exclude("**/module-info.class")
    duplicatesStrategy = DuplicatesStrategy.WARN

    manifest {
        attributes("Main-Class" to "cypher.enforcers.uberjar.UberJarLauncher")
    }

    val isCI = providers.gradleProperty("isCI")
    doFirst {
        if (isCI.isPresent) {
            if (os.isWindows) {
                archiveClassifier = "uber-win"
            } else if (os.isLinux) {
                archiveClassifier = "uber-linux"
            } else if (os.isMacOsX) {
                archiveClassifier = "uber-mac"
            }
        }
    }

}

tasks.register("createM1Jar") {
    val outputFile = layout.buildDirectory.file("jpackage-m1")

    doFirst {
        val ext: JlinkPluginExtension = extensions.getByType(JlinkPluginExtension::class)
        ext.configuration = "m1Configuration"
        ext.jpackage {
            imageOutputDir = outputFile.get().asFile
        }
    }

    dependsOn(tasks.named("jpackage"))
}